For stack and static var mapping:

Examining IR of main function shows that stack variable is enqueued on stack as expected, typically with an ungarbled name. (line 8199 for allocation+stackptr alignment, 8208 for value init). Internally used copies of the original stack variable, the names of which are prefixed with an underscore and serially named (e.g _3 allocated and initialized alongside myvar, lines 8202 and 8209, before call to std::thread::spawn::<stack_map_and_mutate::main::{closure#0}>, are propagated through backend API calls and are eventually mapped to thread memory. Unlike fork(), Rust compiler parses closure function and determines what is used and needs to be mapped to child thread. We know this because testing with an unused stack variable in the main thread but not the child thread resulted in the variable clearly being allocated on the stack but not being copied into one of these variables.

For bare calls of std::thread::spawn(), Rust internally allocates a std::thread::Builder using std::thread::Builder::new() (line 1166) and from there, std::thread::Builder::spawn(...). Calls to even lower level APIs map the used variables to the thread. For static variables, the process is similar, but the scope information is different and the pointer to the global (static) variable is passed instead of copies of a stack variable. This is not surprising, as we know that the virtual memory block of the parent thread will not necessarily map to that of the child thread without violation, so it instead passes down copies to the relevant API calls, while the static variable exists in a different portion of memory and a simple pointer to it can be safely used.

Closure functions are referenced in the IRs serially as closure#n, (e.g closure#0)

Ultimately, it is <std::thread::Builder>::spawn_unchecked::<stack_map_and_mutate::main::{closure#n}> that copies the necessary elements of the stack to the child thread via core::clone::Clone(). It is beyond the scope of our observations to determine if or how core::clone::Clone() resolves internal fragmentation of the stack from this intelligent selective mapping.
